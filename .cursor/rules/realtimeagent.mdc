---
description: 
globs: 
alwaysApply: false
---


下面给出一个基于 LangChainJS0.3和Nextjs 的 “循环式（loop-based）LLM Agentic workflow” 实现思路与代码示例。Agent 能自动截图自检→多模态诊断→生成修正→前端增量更新，实现真正的 AI 驱动 threejs 的3D 场景自我优化闭环

前端使用的是monaco：，结合 Three.js 和 Monaco 编辑器
使用的是AZure OpenAI

流程：
只有第一次用户请求时，才使用直接生成代码的函数生成，以后的情况都进入lint、diff、apply_patch的agent循环，直至循环结束。
每次用户请求后，截图和分析图片功能不经过agent，而是直接调用llm

##
核心思路是：
系统提示（system prompt）静态加载，利用提示缓存；
定义工具（functions），比如 lint、diff、apply_patch
创建 AgentExecutor，设置 maxIterations，让模型在每次调用工具后带入新上下文；
循环执行：Agent 会自动计划调用 functions，执行本地操作并将 <tool_result> 注入对话；
终止条件：当 lint/test 全部通过或达到迭代上限时自动退出

##
注意：
返回JSON格式数据
使用AzureOpenAI和langchainjs0.3的api和函数，接口。


##
工具定义（lint、diff、apply_patch）
在这里，我们使用 Tool 类来封装每个工具（lint、diff、apply_patch）。这些工具会被 LangChain 调用并执行相应的操作：
lint：执行 ESLint 对代码进行检查并返回结构化的错误、警告信息。
diff：根据原始代码与更新代码生成 diff 补丁。
apply_patch：应用 diff 补丁，并返回更新后的代码。


##
LangChain AgentExecutor
使用 initializeAgentExecutorWithOptions 创建 executor，其中包含：
tools：传入需要的工具（lint、diff、apply_patch）。
maxIterations：最多迭代次数，避免无限循环。

