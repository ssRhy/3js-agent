// Type definitions
type MeshMode = "Raw" | "Quad" | "Ultra";
type QualityLevel = "high" | "medium" | "low" | "extra-low";
type MaterialStyle = "pbr" | "shaded";
type FileFormat = "glb" | "usdz" | "fbx" | "obj" | "stl";
type ImageMode = "multi-view" | "fuse";

type GenerateOptions = {
  prompt?: string;
  imageUrls?: string[];
  imageMode?: ImageMode;
  meshMode?: MeshMode;
  meshSimplify?: boolean;
  meshSmooth?: boolean;
  quality?: QualityLevel;
  bboxCondition?: [number, number, number];
  useHyper?: boolean;
  TAPose?: boolean;
  material?: MaterialStyle;
  geometryFileFormat?: FileFormat;
  tier?: string;
};

type GenerateResponse = {
  uuid: string;
  jobs: {
    uuids: string[];
    subscription_key: string;
  };
};

type StatusResponse = {
  jobs: Array<{
    uuid: string;
    status: string;
    progress?: number;
  }>;
};

type DownloadResponse = {
  list: Array<{
    name: string;
    url: string;
    originalName?: string;
    format?: string;
  }>;
};

const HYPER3D_API_URL = process.env.HYPER3D_API_URL;
const HYPER3D_API_KEY = process.env.HYPER3D_API_KEY;

if (!HYPER3D_API_URL || !HYPER3D_API_KEY) {
  throw new Error(
    "HYPER3D_API_URL and HYPER3D_API_KEY environment variables must be set"
  );
}

export const hyper3d = {
  // Generate a 3D model
  generate: async (options: GenerateOptions): Promise<GenerateResponse> => {
    const {
      prompt,
      imageUrls,
      imageMode = "multi-view",
      meshMode = "Quad",
      meshSimplify = true,
      meshSmooth = true,
      quality = "medium",
      bboxCondition,
      useHyper = false,
      TAPose = false,
      material = "pbr",
      geometryFileFormat = "glb",
      tier = "Regular",
    } = options;

    // Prepare request body
    const formData = new FormData();

    // Add tier to form data
    formData.append("tier", tier);

    // Add prompt if provided
    if (prompt) {
      formData.append("prompt", prompt);
    }

    // Add images if provided
    if (imageUrls && imageUrls.length > 0) {
      // Fetch and append all images to form data
      await Promise.all(
        imageUrls.map(async (url, index) => {
          const imageResponse = await fetch(url);
          const imageBlob = await imageResponse.blob();
          formData.append("images", imageBlob, `image${index}.jpg`);
        })
      );

      // Add image mode for multiple images
      if (imageUrls.length > 1) {
        formData.append(
          "condition_mode",
          imageMode === "multi-view" ? "concat" : "fuse"
        );
      }
    }

    // Add mesh settings
    formData.append("mesh_mode", meshMode);
    if (meshMode === "Raw") {
      formData.append("mesh_simplify", meshSimplify.toString());
    } else if (meshMode === "Quad") {
      formData.append("mesh_smooth", meshSmooth.toString());
      formData.append("quality", quality);
    }

    // Add bounding box condition if provided
    if (bboxCondition) {
      bboxCondition.forEach((condition) => {
        formData.append("bbox_condition", condition.toString());
      });
    }

    // Add hyper detail and T/A pose
    formData.append("use_hyper", useHyper.toString());
    formData.append("TAPose", TAPose.toString());

    // Add material and file format
    if (material === "pbr") {
      formData.append("material", material.toUpperCase());
    } else if (material === "shaded") {
      formData.append("material", "Shaded");
    } else {
      formData.append("material", material);
    }

    if (geometryFileFormat === "usdz") {
      formData.append("geometry_file_format", "glb");
    } else {
      formData.append("geometry_file_format", geometryFileFormat);
    }

    console.info("\n\nhyper3d generation formData:", formData, "\n\n");
    // Make API request
    const response = await fetch(`${HYPER3D_API_URL}/rodin`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${HYPER3D_API_KEY}`,
      },
      body: formData,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Hyper3D API error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }

    return await response.json();
  },

  // Check the status of a generation
  checkStatus: async (subscriptionKey: string): Promise<StatusResponse> => {
    const statusUrl = `${HYPER3D_API_URL}${
      HYPER3D_API_URL.includes("/api/v2") ? "" : "/api/v2"
    }/status`;
    console.log(`Checking status with URL: ${statusUrl}`);
    console.log(
      `Request body: ${JSON.stringify({ subscription_key: subscriptionKey })}`
    );
    const response = await fetch(statusUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${HYPER3D_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        subscription_key: subscriptionKey,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Hyper3D API error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }

    return await response.json();
  },

  // Download the generated model
  download: async (
    taskUuid: string,
    format?: FileFormat
  ): Promise<DownloadResponse> => {
    const downloadUrl = `${HYPER3D_API_URL}${
      HYPER3D_API_URL.includes("/api/v2") ? "" : "/api/v2"
    }/download`;
    console.log(`Downloading model with URL: ${downloadUrl}`);
    console.log(`Request body: ${JSON.stringify({ task_uuid: taskUuid, format })}`);
    
    const response = await fetch(downloadUrl, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${HYPER3D_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        task_uuid: taskUuid,
        format: format, // Add format parameter if specified
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Hyper3D API error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }

    const data = await response.json();
    console.log("Raw download data:", data);

    // Process the response to handle different file formats
    return {
      list: data.list.map((item: { name: string; url: string }) => {
        const extension = item.name.split(".").pop() || "";
        const format = extension.toLowerCase() as FileFormat;
        return {
          ...item,
          originalName: item.name,
          name: `${taskUuid}.${extension}`,
          format,
        };
      }),
    };
  },
};

// Import necessary libraries
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import { BufferMemory } from "langchain/memory";

// Memory to store model generation history
const modelGenMemory = new BufferMemory({
  memoryKey: "modelGenHistory",
  inputKey: "prompt",
  returnMessages: false,
});

// Process to generate 3D model, poll for completion, and return the model URL
async function generate3DModel(options: GenerateOptions): Promise<{
  success: boolean;
  message: string;
  modelUrl?: string;
  modelUrls?: string[];
  taskId?: string;
}> {
  try {
    console.log("Generating 3D model with options:", options);

    // Step 1: Generate the model
    const genResponse = await hyper3d.generate(options);
    console.log("Generation response:", genResponse);

    if (!genResponse.jobs?.subscription_key) {
      return {
        success: false,
        message:
          "Failed to start model generation: No subscription key received",
      };
    }

    // Step 2: Poll for status until complete
    const subscriptionKey = genResponse.jobs.subscription_key;
    const taskId = genResponse.uuid;
    let modelReady = false;
    let retries = 0;
    const maxRetries = 300; // 5 minutes with 10-second polling
    let lastProgress = 0;

    while (!modelReady && retries < maxRetries) {
      await new Promise((resolve) => setTimeout(resolve, 10000)); // 10秒轮询一次

      try {
        const statusResponse = await hyper3d.checkStatus(subscriptionKey);
        console.log("Status response:", statusResponse);

        if (!statusResponse.jobs || statusResponse.jobs.length === 0) {
          console.warn("No jobs found in status response");
          retries++;
          continue;
        }

        const job = statusResponse.jobs[0];

        if (job.status === "completed") {
          modelReady = true;
          break;
        } else if (job.status === "failed") {
          return {
            success: false,
            message: "Model generation failed",
            taskId,
          };
        }

        // Update progress if available
        if (job.progress !== undefined && job.progress > lastProgress) {
          lastProgress = job.progress;
          console.log(`Model generation progress: ${lastProgress}%`);
        }

        retries++;
      } catch (statusError) {
        console.error("Error checking model status:", statusError);
        retries++;
      }
    }

    if (!modelReady) {
      return {
        success: false,
        message: "Model generation timed out",
        taskId,
      };
    }

    // Step 3: Get the model URL (always prefer GLB format)
    const downloadResponse = await hyper3d.download(taskId, "glb");
    console.log("Download response:", downloadResponse);

    if (!downloadResponse.list || downloadResponse.list.length === 0) {
      return {
        success: false,
        message: "No model files found in download response",
        taskId,
      };
    }

    // Find the GLB file URL, or use the first available
    const modelFile =
      downloadResponse.list.find(
        (item) => item.format === "glb" || item.name.endsWith(".glb")
      ) || downloadResponse.list[0];
    
    console.log("Selected model file:", modelFile);
    console.log("Model URL for loading:", modelFile.url);

    // Get all available model URLs
    const allModelUrls = downloadResponse.list.map((item) => item.url);
    console.log("All available model URLs:", allModelUrls);

    // Return the URLs for remote loading
    return {
      success: true,
      message: "Model generated successfully",
      modelUrl: modelFile.url, // URL for loading directly in Three.js
      modelUrls: allModelUrls,
      taskId,
    };
  } catch (error) {
    console.error("Error in 3D model generation process:", error);
    return {
      success: false,
      message: `